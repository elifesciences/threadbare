<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>threadbare.operations API documentation</title>
<meta name="description" content="" />
<link href='/threadbare/resources/third-party/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='/threadbare/resources/third-party/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="/threadbare/resources/third-party/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>threadbare.operations</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from functools import wraps, partial
from datetime import datetime
import tempfile
import contextlib
import subprocess
from threading import Timer
import getpass
import pssh.exceptions
import os, sys
from pssh.clients.native import SSHClient as PSSHClient
import gevent
import io
import logging
from . import state
from .common import (
    PromptedException,
    merge,
    subdict,
    rename,
    cwd,
    sudo_wrap_command,
    cwd_wrap_command,
    shell_wrap_command,
    ensure,
)


LOG = logging.getLogger(__name__)


class SSHClient(PSSHClient):
    def __deepcopy__(self, memo):
        # do not copy.deepcopy ourselves or the pssh SSHClient object, just
        # return a reference to the object (self)
        # - https://docs.python.org/3/library/copy.html
        return self


class NetworkError(Exception):
    &#34;generic &#39;died while doing something network-related&#39; catch-all exception class.&#34;
    pass


class WrappedNetworkError(NetworkError):
    &#34;groups several exceptions into a single WrappedNetworkError&#34;

    def __init__(self, exc):
        self.wrapped = exc


def pem_key():
    &#34;&#34;&#34;returns the first private key found in a list of common private keys.
    if none of the keys exist, the default (first) key will be returned.&#34;&#34;&#34;
    id_list = [&#34;id_rsa&#34;, &#34;id_dsa&#34;, &#34;identity&#34;, &#34;id_ecdsa&#34;]
    id_list = [os.path.expanduser(&#34;~/.ssh/&#34; + idstr) for idstr in id_list]
    for id_path in id_list:
        if os.path.isfile(id_path):
            return id_path
        LOG.debug(&#34;key not found: %s&#34; % id_path)

    default = id_list[0]
    return default


def handle(base_kwargs, kwargs):
    &#34;&#34;&#34;handles the merging of the base set of function keyword arguments and their possible overrides.
    `base_kwargs` is a map of the function&#39;s keyword arguments and their defaults.
    `kwargs` are the keyword arguments used when executing the function.

    the keys from `base_kwargs` are used to determine which keys to extract from the `kwargs` and any
    global settings.

    returns a triple of (`global_kwargs`, `user_kwargs`, `final_kwargs`) where
    `global_kwargs` is the subset of keyword arguments extracted from `state.env`,
    `user_kwargs` is the subset of keyword arguments extracted from the given kwargs and
    `final_kwargs` is the result of merging `base_kwargs` &lt;- `global_kwargs` &lt;- `user_kwargs`

    &#39;user&#39; keyword arguments that are explicitly passed in take precedence over all others and
    &#39;global&#39; keyword arguments take precedence over the function&#39;s defaults kwargs.&#34;&#34;&#34;
    key_list = base_kwargs.keys()
    global_kwargs = subdict(state.ENV, key_list)
    user_kwargs = subdict(kwargs, key_list)
    final_kwargs = merge(base_kwargs, global_kwargs, user_kwargs)
    return global_kwargs, user_kwargs, final_kwargs


# api


@contextlib.contextmanager
def lcd(local_dir):
    &#34;temporarily changes the local working directory&#34;
    ensure(os.path.isdir(local_dir), &#34;not a directory: %s&#34; % local_dir)
    with state.settings():
        current_dir = cwd()
        state.add_cleanup(lambda: os.chdir(current_dir))
        os.chdir(local_dir)
        yield


@contextlib.contextmanager
def rcd(remote_working_dir):
    &#34;ensures all commands run are done from the given remote directory. if remote directory doesn&#39;t exist, command will not be run&#34;
    with state.settings(remote_working_dir=remote_working_dir):
        yield


@contextlib.contextmanager
def hide(what=None):
    &#34;hides *all* output, regardless of `what` type of output is to be hidden.&#34;
    with state.settings(quiet=True):
        yield


def _ssh_default_settings():
    &#34;default settings for dealing with ssh.&#34;
    return {
        # current user. sensible default but probably not what you want
        &#34;user&#34;: getpass.getuser(),
        &#34;host_string&#34;: None,
        # looks for the same ~4 possible keys as Fabric and ParallelSSH.
        # uses the first one it finds or the most common if none found.
        &#34;key_filename&#34;: pem_key(),
        &#34;port&#34;: 22,
        &#34;use_shell&#34;: True,
        &#34;use_sudo&#34;: False,
        &#34;combine_stderr&#34;: True,
        &#34;quiet&#34;: False,
        &#34;remote_working_dir&#34;: None,
        &#34;timeout&#34;: None,
        &#34;warn_only&#34;: False,  # https://github.com/mathiasertl/fabric/blob/master/fabric/state.py#L301-L305
        &#34;abort_exception&#34;: RuntimeError,
    }


def _ssh_client(**kwargs):
    &#34;&#34;&#34;returns an instance of pssh.clients.native.SSHClient
    if within a state context, looks for a client already in use and returns that if found.
    if not found, creates a new one and stores it for later use.&#34;&#34;&#34;

    # parameters we&#39;re interested in and their default values
    base_kwargs = subdict(
        _ssh_default_settings(), [&#34;user&#34;, &#34;host_string&#34;, &#34;key_filename&#34;, &#34;port&#34;]
    )
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)
    final_kwargs[&#34;password&#34;] = None  # always private keys
    rename(final_kwargs, [(&#34;key_filename&#34;, &#34;pkey&#34;), (&#34;host_string&#34;, &#34;host&#34;)])

    # if we&#39;re not using global state, return the new client as-is
    env = state.ENV
    if env.read_only:
        return SSHClient(**final_kwargs)

    client_map_key = &#34;ssh_client&#34;
    client_key = subdict(final_kwargs, [&#34;user&#34;, &#34;host&#34;, &#34;pkey&#34;, &#34;port&#34;, &#34;timeout&#34;])
    client_key = tuple(sorted(client_key.items()))

    # otherwise, check to see if a previous client is available for this host
    client_map = env.get(client_map_key, {})
    if client_key in client_map:
        return client_map[client_key]

    # if not, create a new one and store it in the state

    # https://parallel-ssh.readthedocs.io/en/latest/native_single.html#pssh.clients.native.single.SSHClient
    client = SSHClient(**final_kwargs)

    # disconnect session when leaving context manager
    state.add_cleanup(lambda: client.disconnect())

    client_map[client_key] = client
    env[client_map_key] = client_map

    return client


def _execute(command, user, key_filename, host_string, port, use_pty, timeout):
    &#34;&#34;&#34;creates an SSHClient object and executes given `command` with the given parameters.&#34;&#34;&#34;
    client = _ssh_client(
        user=user, host_string=host_string, key_filename=key_filename, port=port
    )

    shell = False  # handled ourselves
    sudo = False  # handled ourselves
    user = None  # user to sudo to
    encoding = &#34;utf-8&#34;  # used everywhere

    # https://parallel-ssh.readthedocs.io/en/latest/native_single.html#pssh.clients.native.single.SSHClient.run_command
    # https://github.com/ParallelSSH/parallel-ssh/blob/master/pssh/output.py
    host_output = client.run_command(
        command, sudo, user, use_pty, shell, encoding, timeout
    )

    host_string = host_output.host
    stdout = host_output.stdout
    stderr = host_output.stderr

    def get_exit_code():
        client.wait_finished(host_output)
        return host_output.exit_code

    return {
        # defer executing as it consumes output entirely before returning. this
        # removes our chance to display/transform output as it is streamed to us
        &#34;return_code&#34;: get_exit_code,
        &#34;command&#34;: command,
        &#34;stdout&#34;: stdout,
        &#34;stderr&#34;: stderr,
    }


def _print_line(output_pipe, line, **kwargs):
    &#34;&#34;&#34;writes the given `line` (string) to the given `output_pipe` (file-like object)
    if `quiet` is True, `line` is *not* written to `output_pipe`.
    if `discard_output` is True, `line` is *not* returned and output does *not* accumulate in memory.&#34;&#34;&#34;

    base_kwargs = {
        &#34;discard_output&#34;: False,
        &#34;quiet&#34;: False,
        &#34;line_template&#34;: &#34;[{host}] {pipe}: {line}\n&#34;,  # &#34;1.2.3.4  err: Foo not found\n&#34;
        &#34;display_prefix&#34;: True,  # strips everything in `line_template` before &#34;{line}&#34;
        &#34;custom_pipe&#34;: None,
    }
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    if not final_kwargs[&#34;quiet&#34;]:
        # useful values that can be part of the template
        pipe_type = &#34;err&#34; if output_pipe == sys.stderr else &#34;out&#34;
        if final_kwargs[&#34;custom_pipe&#34;]:
            pipe_type = final_kwargs[&#34;custom_pipe&#34;]  # like &#34;run&#34;

        dt = datetime.now()
        template_kwargs = {
            &#34;line&#34;: line,
            &#34;year&#34;: dt.year,
            &#34;month&#34;: dt.month,
            &#34;day&#34;: dt.day,
            &#34;hour&#34;: dt.hour,
            &#34;minute&#34;: dt.minute,
            &#34;second&#34;: dt.second,
            &#34;ms&#34;: dt.microsecond,
            &#34;host&#34;: state.ENV.get(&#34;host_string&#34;, &#34;&#34;),
            &#34;pipe&#34;: pipe_type,
        }

        # render template and write to given pipe
        template = final_kwargs[&#34;line_template&#34;]

        if not final_kwargs[&#34;display_prefix&#34;]:
            try:
                template = template[template.index(&#34;{line}&#34;) :]
            except ValueError:  # &#34;substring not found&#34;
                msg = &#34;&#39;display_prefix&#39; option ignored: &#39;{line}&#39; not found in &#39;line_template&#39; setting&#34;
                LOG.warning(msg)

        output_pipe.write(template.format(**template_kwargs))

    if not final_kwargs[&#34;discard_output&#34;]:
        return line  # free of any formatting


def _process_output(output_pipe, result_buffer, **kwargs):
    &#34;calls `_print_line` on each result in `result_list`.&#34;

    # always process the results as soon as we have them
    # use `quiet=True` to hide the printing of output to stdout/stderr
    # use `discard_output=True` to discard the results as soon as they are read.
    # `stderr` results may be empty if `combine_stderr` in call to `remote` was `True`
    new_results = [_print_line(output_pipe, line, **kwargs) for line in result_buffer]
    output_pipe.flush()
    if &#34;discard_output&#34; in kwargs and not kwargs[&#34;discard_output&#34;]:
        return new_results


def _print_running(command, output_pipe, **kwargs):
    &#34;&#34;&#34;Prints the command to be run on a line of output prior to executing a command.
    Obeys the formatting and rules of the context in which the command is being exected.
    Deprecated. This is to mimic Fabric&#39;s command output until we&#39;re sure nothing depends on it.
    It will be replaced with a standard LOG.info output eventually.&#34;&#34;&#34;
    keepers = [&#34;display_running&#34;, &#34;quiet&#34;, &#34;discard_output&#34;, &#34;line_template&#34;]
    kwargs = subdict(kwargs, keepers)
    if kwargs[&#34;display_running&#34;]:
        if not isinstance(command, list):
            command = [command]
        command = &#34; &#34;.join(command)
        return _print_line(output_pipe, command, custom_pipe=&#34;run&#34;, **kwargs)


def abort(result, err_msg, **kwargs):
    &#34;&#34;&#34;raises a `RuntimeError` with the given `err_msg` and the given `result` attached to it&#39;s `.result` property.
    issues a warning and returns the given `result` if `settings.warn_only` is `True`.
    raises a SystemExit with a return code of `1` if `settings.abort_exception` is set to None.&#34;&#34;&#34;
    base_kwargs = {
        &#34;quiet&#34;: False,
        &#34;warn_only&#34;: False,
        &#34;display_aborts&#34;: True,
        &#34;abort_exception&#34;: RuntimeError,
    }
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    if final_kwargs[&#34;warn_only&#34;]:
        if not final_kwargs[&#34;quiet&#34;]:
            LOG.warning(err_msg)
        return result

    if final_kwargs[&#34;display_aborts&#34;]:
        if not final_kwargs[&#34;quiet&#34;]:
            LOG.error(&#34;Fatal error: %s&#34; % err_msg)

    abort_exc_klass = final_kwargs[&#34;abort_exception&#34;]
    if abort_exc_klass:
        exc = abort_exc_klass(err_msg)
        setattr(exc, &#34;result&#34;, result)
        raise exc

    # https://docs.python.org/3/library/exceptions.html#SystemExit
    # # https://github.com/mathiasertl/fabric/blob/master/fabric/utils.py#L30-L63
    exc = SystemExit(1)
    exc.message = err_msg
    raise exc


# https://github.com/mathiasertl/fabric/blob/master/fabric/state.py#L338
# https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L898-L901
# https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L975
def remote(command, **kwargs):
    &#34;preprocesses given `command` and options before sending it to `_execute` to be executed on remote host&#34;

    # Fabric function signature for `run`
    # shell=True # done
    # pty=True   # mutually exclusive with `combine_stderr` in pssh. not sure how Fabric/Paramiko is doing it
    # combine_stderr=None # mutually exclusive with use_pty. &#39;True&#39; in global env.
    # quiet=False, # done
    # warn_only=False # done
    # stdout=None # done, stdout/stderr always available unless explicitly discarded. &#39;see discard_output&#39;
    # stderr=None # done, stderr not available when combine_stderr is `True`
    # timeout=None # done
    # shell_escape=None # ignored. shell commands are always escaped
    # capture_buffer_size=None # correlates to `ssh2.channel.read` and the `size` parameter. Ignored.

    # parameters we&#39;re interested in and their default values
    base_kwargs = _ssh_default_settings()
    base_kwargs.update({&#34;display_running&#34;: True, &#34;discard_output&#34;: False})
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    # wrap the command up
    # https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L920-L925
    if final_kwargs[&#34;remote_working_dir&#34;]:
        command = cwd_wrap_command(command, final_kwargs[&#34;remote_working_dir&#34;])
    if final_kwargs[&#34;use_shell&#34;]:
        command = shell_wrap_command(command)
    if final_kwargs[&#34;use_sudo&#34;]:
        command = sudo_wrap_command(command)

    # if use_pty is True, stdout and stderr are combined and stderr will yield nothing.
    # - https://parallel-ssh.readthedocs.io/en/latest/advanced.html#combined-stdout-stderr
    use_pty = final_kwargs[&#34;combine_stderr&#34;]

    # values `remote` specifically passes to `_execute`
    execute_kwargs = {&#34;command&#34;: command, &#34;use_pty&#34;: use_pty}
    execute_kwargs = merge(final_kwargs, execute_kwargs)
    execute_kwargs = subdict(
        execute_kwargs,
        [
            &#34;command&#34;,
            &#34;user&#34;,
            &#34;key_filename&#34;,
            &#34;host_string&#34;,
            &#34;port&#34;,
            &#34;use_pty&#34;,
            &#34;timeout&#34;,
        ],
    )

    # TODO: validate `_execute`s args. `host_string` can&#39;t be None for example

    # run command
    _print_running(command, sys.stdout, **final_kwargs)
    result = _execute(**execute_kwargs)

    # handle stdout/stderr streams
    output_kwargs = subdict(final_kwargs, [&#34;quiet&#34;, &#34;discard_output&#34;])
    stdout = _process_output(sys.stdout, result[&#34;stdout&#34;], **output_kwargs)
    stderr = _process_output(sys.stderr, result[&#34;stderr&#34;], **output_kwargs)

    # command must have finished before we have access to return code
    return_code = result[&#34;return_code&#34;]()
    result.update(
        {
            &#34;stdout&#34;: stdout,
            &#34;stderr&#34;: stderr,
            &#34;return_code&#34;: return_code,
            &#34;failed&#34;: return_code &gt; 0,
            &#34;succeeded&#34;: return_code == 0,
        }
    )

    if result[&#34;succeeded&#34;]:
        return result

    err_msg = &#34;remote() encountered an error (return code %s) while executing %r&#34; % (
        result[&#34;return_code&#34;],
        command,
    )

    # if `warn_only` is True this function may still return a result
    return abort(result, err_msg, **final_kwargs)


# https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L1100
def remote_sudo(command, **kwargs):
    &#34;exactly the same as `remote`, but the given command is run as the root user&#34;
    # user=None  # ignore
    # group=None # ignore
    kwargs[&#34;use_sudo&#34;] = True
    return remote(command, **kwargs)


# https://github.com/mathiasertl/fabric/blob/master/fabric/contrib/files.py#L15
def remote_file_exists(path, **kwargs):
    &#34;returns True if given path exists on remote system&#34;
    # note: Fabric is doing something weird and clever here:
    # - https://github.com/mathiasertl/fabric/blob/master/fabric/contrib/files.py#L474-L485
    # but their examples don&#39;t work:

    # $ /bin/sh
    # sh-5.0$ foo=&#34;$(echo /usr/\*/share)&#34;
    # sh-5.0$ echo $foo
    # /usr/*/share
    # sh-5.0$ exit
    # $ echo $SHELL
    # $ /bin/bash
    # $ foo=&#34;$(echo /usr/\*/share)&#34;
    # $ echo $foo
    # /usr/*/share

    # TODO: revisit
    # update 2020/01: it does work, I just had no &#34;/usr/[anything]/share&#34; directories.
    # this works for me:
    #   foo=$(echo /\*/share/)
    #   echo $foo
    #   /usr/share/

    base_kwargs = {
        &#34;use_sudo&#34;: False,
    }
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    # do not raise an exception if remote file doesn&#39;t exist
    final_kwargs[&#34;warn_only&#34;] = True

    remote_fn = remote_sudo if final_kwargs[&#34;use_sudo&#34;] else remote
    command = &#34;test -e %s&#34; % path
    return remote_fn(command, **final_kwargs)[&#34;return_code&#34;] == 0


# https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L1157
def local(command, **kwargs):
    &#34;preprocesses given `command` and options before executing it locally using Python&#39;s `subprocess.Popen`&#34;
    base_kwargs = {
        &#34;use_sudo&#34;: False,
        &#34;use_shell&#34;: True,
        &#34;combine_stderr&#34;: True,
        &#34;capture&#34;: False,
        &#34;timeout&#34;: None,
        &#34;quiet&#34;: False,
        &#34;display_running&#34;: True,
        &#34;warn_only&#34;: False,  # https://github.com/mathiasertl/fabric/blob/master/fabric/state.py#L301-L305
        &#34;abort_exception&#34;: RuntimeError,
    }
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    if final_kwargs[&#34;capture&#34;]:
        if final_kwargs[&#34;combine_stderr&#34;]:
            out_stream = subprocess.PIPE
            err_stream = subprocess.STDOUT
        else:
            out_stream = subprocess.PIPE
            err_stream = subprocess.PIPE
    else:
        if final_kwargs[&#34;quiet&#34;]:
            # we&#39;re not capturing and we&#39;ve been told to be quiet
            # send everything to /dev/null
            out_stream = subprocess.DEVNULL
            err_stream = subprocess.DEVNULL
        else:
            out_stream = None
            err_stream = None

    if not final_kwargs[&#34;use_shell&#34;] and not isinstance(command, list):
        raise ValueError(&#34;when shell=False, given command *must* be a list&#34;)

    if final_kwargs[&#34;use_shell&#34;]:
        command = shell_wrap_command(command)

    if final_kwargs[&#34;use_sudo&#34;]:
        if final_kwargs[&#34;use_shell&#34;]:
            command = sudo_wrap_command(command)
        else:
            # lsh@2020-04: is this a good enough sudo command?
            # nothing uses local+noshell+sudo (at time of writing)
            command = [&#34;sudo&#34;, &#34;--non-interactive&#34;] + command

    proc = subprocess.Popen(
        command, shell=final_kwargs[&#34;use_shell&#34;], stdout=out_stream, stderr=err_stream
    )
    _print_running(command, sys.stdout, **final_kwargs)
    if final_kwargs[&#34;timeout&#34;]:
        timer = Timer(final_kwargs[&#34;timeout&#34;], proc.kill)
        try:
            timer.start()  # proximity matters
            stdout, stderr = proc.communicate()
        finally:
            timer.cancel()
    else:
        stdout, stderr = proc.communicate()

    # https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L1240-L1244
    result = {
        &#34;return_code&#34;: proc.returncode,
        &#34;failed&#34;: proc.returncode != 0,
        &#34;succeeded&#34;: proc.returncode == 0,
        &#34;command&#34;: command,
        &#34;stdout&#34;: (stdout or b&#34;&#34;).decode(&#34;utf-8&#34;).splitlines(),
        &#34;stderr&#34;: (stderr or b&#34;&#34;).decode(&#34;utf-8&#34;).splitlines(),
    }

    if result[&#34;succeeded&#34;]:
        return result

    err_msg = &#34;local() encountered an error (return code %s) while executing %r&#34; % (
        result[&#34;return_code&#34;],
        command,
    )

    # if `warn_only` is True this function may still return a result
    return abort(result, err_msg, **final_kwargs)


def single_command(cmd_list):
    &#34;given a list of commands to run, returns a single command.&#34;
    # `remote` and `local` will do any escaping as necessary
    if cmd_list in [None, []]:
        return None
    return &#34; &amp;&amp; &#34;.join(map(str, cmd_list))


def prompt(msg):
    &#34;&#34;&#34;issues a prompt for input.
    raises a `PromptedException` if `abort_on_prompts` in `state.ENV` is `True` or executing within
    another process using `execute.parallel` where input can&#39;t be supplied.
    if `abort_exception` is set in `state.ENV`, then that exception is raised instead&#34;&#34;&#34;
    if state.ENV.get(&#34;abort_on_prompts&#34;, False):
        abort_ex = state.ENV.get(&#34;abort_exception&#34;, PromptedException)
        raise abort_ex(&#34;prompted with: %s&#34; % (msg,))
    print(msg)
    try:
        return raw_input(&#34;&gt; &#34;)
    except NameError:
        return input(&#34;&gt; &#34;)


#
# uploads and downloads
#


def execute_rsync_command(cmd):
    &#34;&#34;&#34;executes given rsync `cmd`, catching rsync errors and improving any errors raised.
    rsync commands can be generated with `_rsync_upload` and `_rsync_download` functions.
    &#34;&#34;&#34;
    try:
        return local(cmd)
    except Exception as uncaught_exc:
        if hasattr(uncaught_exc, &#34;result&#34;):
            # this is a threadbare error and we may be able to improve it
            result = uncaught_exc.result
            # taken straight from the `man` page, authored &#34;28 Jan 2018&#34;
            error_map = {
                1: &#34;Syntax or usage error&#34;,
                2: &#34;Protocol incompatibility&#34;,
                3: &#34;Errors selecting input/output files, dirs&#34;,
                4: &#34;Requested  action  not supported: an attempt was made to manipulate 64-bit files on a platform that cannot support them; or an option was specified that is supported by the client and not by the server.&#34;,
                5: &#34;Error starting client-server protocol&#34;,
                6: &#34;Daemon unable to append to log-file&#34;,
                10: &#34;Error in socket I/O&#34;,
                11: &#34;Error in file I/O&#34;,
                12: &#34;Error in rsync protocol data stream&#34;,
                13: &#34;Errors with program diagnostics&#34;,
                14: &#34;Error in IPC code&#34;,
                20: &#34;Received SIGUSR1 or SIGINT&#34;,
                21: &#34;Some error returned by waitpid()&#34;,
                22: &#34;Error allocating core memory buffers&#34;,
                23: &#34;Partial transfer due to error&#34;,
                24: &#34;Partial transfer due to vanished source files&#34;,
                25: &#34;The --max-delete limit stopped deletions&#34;,
                30: &#34;Timeout in data send/receive&#34;,
                35: &#34;Timeout waiting for daemon connection&#34;,
            }
            if result[&#34;return_code&#34;] in error_map:
                raise NetworkError(
                    &#34;rsync returned error %s: %s&#34;
                    % (result[&#34;return_code&#34;], error_map[result[&#34;return_code&#34;]])
                )
        raise uncaught_exc


def _rsync_upload(local_path, remote_path, **kwargs):
    &#34;&#34;&#34;generates an rsync command to copy `local_path` to `remote_path` using values in the current `state.ENV`.
    does *not* execute command. see `rsync_upload` and `execute_rsync_command`.&#34;&#34;&#34;

    base_kwargs = subdict(
        _ssh_default_settings(), [&#34;user&#34;, &#34;host_string&#34;, &#34;key_filename&#34;, &#34;port&#34;]
    )
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    cmd = [
        &#34;rsync&#34;,
        # &#39;-i&#39; is &#39;identity file&#39;
        # note: without &#39;StrictHostKeyChecking&#39; we&#39;ll be given a prompt during testing. is this solvable?
        &#34;--rsh=&#39;ssh -i %s -p %s -o StrictHostKeyChecking=no&#39;&#34;
        % (final_kwargs[&#34;key_filename&#34;], final_kwargs[&#34;port&#34;]),
        local_path,
        &#34;%s@%s:%s&#34; % (final_kwargs[&#34;user&#34;], final_kwargs[&#34;host_string&#34;], remote_path),
    ]
    return &#34; &#34;.join(cmd)


def rsync_upload(local_path, remote_path, **kwargs):
    &#34;copies `local_path` to `remote_path` using values in the current `state.ENV`.&#34;
    remote_dir = os.path.dirname(remote_path)
    if not remote_file_exists(remote_dir):
        remote(&#34;mkdir -p %r&#34; % remote_dir)
    return execute_rsync_command(_rsync_upload(local_path, remote_path, **kwargs))


def _rsync_download(remote_path, local_path, **kwargs):
    &#34;&#34;&#34;generates an rsync command to copy `remote_path` to `local_path` using values in the current `state.ENV`.
    does *not* execute command. see `rsync_download` and `execute_rsync_command`.&#34;&#34;&#34;
    base_kwargs = subdict(
        _ssh_default_settings(), [&#34;user&#34;, &#34;host_string&#34;, &#34;key_filename&#34;, &#34;port&#34;]
    )
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)
    cmd = [
        &#34;rsync&#34;,
        # &#39;-i&#39; is &#39;identity file&#39;
        # without &#39;StrictHostKeyChecking&#39; we&#39;ll be given a prompt during testing.
        &#34;--rsh=&#39;ssh -i %s -p %s -o StrictHostKeyChecking=no&#39;&#34;
        % (final_kwargs[&#34;key_filename&#34;], final_kwargs[&#34;port&#34;]),
        &#34;%s@%s:%s&#34; % (final_kwargs[&#34;user&#34;], final_kwargs[&#34;host_string&#34;], remote_path),
        local_path,
    ]
    return &#34; &#34;.join(cmd)


def rsync_download(remote_path, local_path, **kwargs):
    &#34;copies `remote_path` to `local_path` using values in the current `state.ENV`.&#34;
    abs_local_path = os.path.abspath(os.path.expanduser(local_path))
    abs_local_dir = os.path.dirname(abs_local_path)
    if not os.path.exists(abs_local_dir):
        # replicates behaviour of downloading via scp and sftp (via parallel-ssh)
        local(&#34;mkdir -p %r&#34; % (abs_local_dir,))
    return execute_rsync_command(_rsync_download(remote_path, local_path, **kwargs))


def _transfer_fn(client, direction, **kwargs):
    &#34;&#34;&#34;returns the `client` object&#39;s appropriate transfer *method* given a `direction`.
    `direction` is either &#39;upload&#39; or &#39;download&#39;.
    Also accepts the `transfer_protocol` keyword parameter that is either &#39;rsync&#39; (default), &#39;scp&#39; or &#39;sftp&#39;.&#34;&#34;&#34;
    base_kwargs = {
        &#34;overwrite&#34;: True,
        # sftp is *exceptionally* slow.
        # Paramiko&#39;s implementation is faster than native SFTP but slower than SCP:
        # - https://github.com/ParallelSSH/parallel-ssh/issues/177
        # however, SCP is buggy and may randomly hang or complete without uploading anything.
        # take slow and reliable over fast and buggy.
        &#34;transfer_protocol&#34;: &#34;rsync&#34;,  # &#34;sftp&#34;,  # &#34;scp&#34;
    }
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    def upload_fn(fn):
        @wraps(fn)
        def wrapper(local_file, remote_file):
            if remote_file_exists(remote_file) and not final_kwargs[&#34;overwrite&#34;]:
                raise NetworkError(
                    &#34;Remote file exists and &#39;overwrite&#39; is set to &#39;False&#39;. Refusing to write: %s&#34;
                    % (remote_file,)
                )

            if final_kwargs[&#34;transfer_protocol&#34;] == &#34;rsync&#34;:
                fn(local_file, remote_file)
            else:
                # https://github.com/ParallelSSH/parallel-ssh/blob/8b7bb4bcb94d913c3b7da77db592f84486c53b90/pssh/clients/native/parallel.py#L524
                g = fn(local_file, remote_file)
                if g:
                    gevent.joinall(g, raise_error=True)

            # lsh@2020-04, local testing didn&#39;t reveal anything but small files uploaded via SCP SCP during CI
            # were either missing or had empty bodies. SFTP seemed to be fine.
            # This sanity check seems to fix the issue (lending more credence to my theory it&#39;s an unflushed buffer somewhere),
            # when waiting 3 seconds between upload of file and check of file was still failing.
            ensure(
                remote_file_exists(remote_file, **kwargs),
                &#34;failed to upload file, remote file does not exist: %s&#34;
                % (remote_file,),
            )

        return wrapper

    def download_fn(fn):
        @wraps(fn)
        def wrapper(remote_file, local_file):

            if not final_kwargs[&#34;overwrite&#34;] and os.path.exists(local_file):
                raise NetworkError(
                    &#34;Local file exists and &#39;overwrite&#39; is set to &#39;False&#39;. Refusing to write: %s&#34;
                    % (local_file,)
                )
            if final_kwargs[&#34;transfer_protocol&#34;] == &#34;rsync&#34;:
                fn(remote_file, local_file)
            else:
                # https://github.com/ParallelSSH/parallel-ssh/blob/d812ff32d828009ddb94f458fe43920c22df4c0e/pssh/clients/native/single.py#L558
                g = fn(remote_file, local_file)
                if g:
                    gevent.joinall(g, raise_error=True)

        return wrapper

    upload_backends = {
        &#34;sftp&#34;: partial(client.copy_file, recurse=True),
        &#34;scp&#34;: partial(client.scp_send, recurse=True),
        &#34;rsync&#34;: rsync_upload,
    }

    download_backends = {
        &#34;sftp&#34;: client.copy_remote_file,
        &#34;scp&#34;: client.scp_recv,
        &#34;rsync&#34;: rsync_download,
    }

    direction_map = {&#34;upload&#34;: upload_backends, &#34;download&#34;: download_backends}
    ensure(
        direction in direction_map,
        &#34;you can &#39;upload&#39; or &#39;download&#39; but not %r&#34; % (direction,),
    )

    backend_map = direction_map[direction]
    transfer_protocol = final_kwargs[&#34;transfer_protocol&#34;]
    ensure(
        transfer_protocol in backend_map,
        &#34;unhandled transfer protocol %r; supported protocols: %s&#34;
        % (transfer_protocol, &#34;, &#34;.join(backend_map.keys())),
    )

    transfer_fn = direction_map[direction][transfer_protocol]

    direction_wrapper_map = {&#34;upload&#34;: upload_fn, &#34;download&#34;: download_fn}
    wrapper_fn = direction_wrapper_map[direction]

    return wrapper_fn(transfer_fn)


# https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L419
# use_sudo hack: https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L453-L458
def _download_as_root_hack(remote_path, local_path, **kwargs):
    &#34;&#34;&#34;as root, creates a temporary copy of the file that can be downloaded by a
    regular user and then removes the temporary file.
    warning: don&#39;t try to download anything huge `with_sudo` as the file is duplicated.
    warning: the privileged file will be available in /tmp until the download is complete&#34;&#34;&#34;

    if not remote_file_exists(remote_path, use_sudo=True, **kwargs):
        raise EnvironmentError(&#34;remote file does not exist: %s&#34; % (remote_path,))
    client = _ssh_client(**kwargs)

    cmd = single_command(
        [
            # create a temporary file with the suffix &#39;-threadbare&#39;
            &#39;tempfile=$(mktemp --suffix &#34;-threadbare&#34;)&#39;,
            # copy the target file to this temporary file
            &#39;cp &#34;%s&#34; &#34;$tempfile&#34;&#39; % remote_path,
            # ensure it&#39;s readable by the user doing the downloading
            &#39;chmod +r &#34;$tempfile&#34;&#39;,
            # emit the name of the temporary file so we can find it to download it
            &#39;echo &#34;$tempfile&#34;&#39;,
        ]
    )
    result = remote_sudo(cmd, **kwargs)
    remote_tempfile = result[&#34;stdout&#34;][-1]
    remote_path = remote_tempfile

    transfer_fn = _transfer_fn(client, &#34;download&#34;, **kwargs)

    try:
        transfer_fn(remote_tempfile, local_path)
        return local_path

    except (pssh.exceptions.SFTPError, pssh.exceptions.SCPError) as exc:
        # permissions or network issues may cause these
        raise WrappedNetworkError(exc)

    finally:
        remote_sudo(&#39;rm -f &#34;%s&#34;&#39; % remote_tempfile, **kwargs)


# https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L419
# use_sudo hack: https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L453-L458
def download(remote_path, local_path, use_sudo=False, **kwargs):
    &#34;&#34;&#34;downloads file at `remote_path` to `local_path`, overwriting the local path if it exists.
    avoid `use_sudo` if at all possible&#34;&#34;&#34;

    with state.settings(quiet=True):
        if remote_path.endswith(&#34;/&#34;):
            raise ValueError(&#34;directory downloads are not supported&#34;)

        # do not raise an exception if remote path is a directory
        result = remote(
            &#39;test -d &#34;%s&#34;&#39; % remote_path, use_sudo=use_sudo, warn_only=True, quiet=True
        )
        remote_path_is_dir = result[&#34;succeeded&#34;]
        if remote_path_is_dir:
            raise ValueError(&#34;directory downloads are not supported&#34;)

        temp_file, data_buffer = None, None
        if hasattr(local_path, &#34;read&#34;):
            # given a file-like object to download file into.
            # 1. write the remote file to local temporary file
            # 2. read temporary file into the given buffer
            # 3. delete the temporary file

            data_buffer = local_path
            temp_file, local_path = tempfile.mkstemp(suffix=&#34;-threadbare&#34;)

        if not os.path.isabs(local_path):
            local_path = os.path.abspath(local_path)

        if os.path.isdir(local_path):
            local_path = os.path.join(local_path, os.path.basename(remote_path))

        if use_sudo:
            local_path = _download_as_root_hack(remote_path, local_path, **kwargs)

        else:
            if not remote_file_exists(remote_path, **kwargs):
                raise EnvironmentError(
                    &#34;remote file does not exist: %s&#34; % (remote_path,)
                )
            client = _ssh_client(**kwargs)
            transfer_fn = _transfer_fn(client, &#34;download&#34;, **kwargs)

            try:
                transfer_fn(remote_path, local_path)
            except (pssh.exceptions.SFTPError, pssh.exceptions.SCPError) as exc:
                # permissions or network issues may cause these
                raise WrappedNetworkError(exc)

        if temp_file:
            flags = &#34;r&#34; if isinstance(data_buffer, io.StringIO) else &#34;rb&#34;
            with open(local_path, flags) as fh:
                data = fh.read()
            data_buffer.write(data)
            # deletes the *temporary file*. `temp_file` is a file descriptor
            os.unlink(local_path)
            return data_buffer

        return local_path


def _upload_as_root_hack(local_path, remote_path, **kwargs):
    &#34;&#34;&#34;uploads file at `local_path` to a remote temporary file then moves the file to `remote_path` as root.
    does not alter any permissions or attributes on the file&#34;&#34;&#34;

    client = _ssh_client(**kwargs)

    cmd = single_command(
        [
            # create a temporary file with the suffix &#39;-threadbare&#39;
            &#39;tempfile=$(mktemp --suffix &#34;-threadbare&#34;)&#39;,
            &#39;echo &#34;$tempfile&#34;&#39;,
        ]
    )
    result = remote(cmd, **kwargs)
    remote_temp_path = result[&#34;stdout&#34;][-1]
    ensure(
        remote_file_exists(remote_temp_path, **kwargs),
        &#34;remote temporary file %r (%s) does not exist&#34;
        % (remote_temp_path, remote_path),
    )

    transfer_fn = _transfer_fn(client, &#34;upload&#34;, **kwargs)

    try:
        transfer_fn(local_path, remote_temp_path)
        move_file_into_place = &#39;mv &#34;%s&#34; &#34;%s&#34;&#39; % (remote_temp_path, remote_path)
        remote_sudo(move_file_into_place, **kwargs)
        ensure(
            remote_file_exists(remote_path, use_sudo=True, **kwargs),
            &#34;remote path does not exist: %s&#34; % (remote_path),
        )
    except (pssh.exceptions.SFTPError, pssh.exceptions.SCPError) as exc:
        # permissions or network issues may cause these
        raise WrappedNetworkError(exc)


def _write_bytes_to_temporary_file(local_path):
    &#34;&#34;&#34;if `local_path` is a file-like object, write the contents to an *actual* file and
    return a pair of new local filename and a function that removes the temporary file when called.&#34;&#34;&#34;
    if hasattr(local_path, &#34;read&#34;):
        # `local_path` is a file-like object
        local_bytes = local_path
        local_bytes.seek(0)  # reset internal pointer
        temp_file, local_path = tempfile.mkstemp(suffix=&#34;-threadbare&#34;)
        with os.fdopen(temp_file, &#34;wb&#34;) as fh:
            data = local_bytes.getvalue()
            # data may be a string or it may be bytes.
            # if it&#39;s a string we assume it&#39;s a UTF-8 string.
            if isinstance(data, str):
                data = bytes(data, &#34;utf-8&#34;)
            fh.write(data)
        cleanup = lambda: os.unlink(local_path)
        return local_path, cleanup
    return local_path, None


def upload(local_path, remote_path, use_sudo=False, **kwargs):
    &#34;uploads file at `local_path` to the given `remote_path`, overwriting anything that may be at that path&#34;
    # todo: this setting is dubious, don&#39;t count on it hanging around
    with state.settings(quiet=True):

        # bytes handling
        local_path, cleanup_fn = _write_bytes_to_temporary_file(local_path)
        if cleanup_fn:
            state.add_cleanup(cleanup_fn)

        if os.path.isdir(local_path):
            raise ValueError(&#34;folders cannot be uploaded&#34;)

        if use_sudo:
            return _upload_as_root_hack(local_path, remote_path, **kwargs)

        if not os.path.exists(local_path):
            raise EnvironmentError(&#34;local file does not exist: %s&#34; % (local_path,))

        client = _ssh_client(**kwargs)

        try:
            transfer_fn = _transfer_fn(client, &#34;upload&#34;, **kwargs)
            transfer_fn(local_path, remote_path)
        except (pssh.exceptions.SFTPError, pssh.exceptions.SCPError) as exc:
            # permissions or network issues may cause these
            raise WrappedNetworkError(exc)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="threadbare.operations.abort"><code class="name flex">
<span>def <span class="ident">abort</span></span>(<span>result, err_msg, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>raises a <code>RuntimeError</code> with the given <code>err_msg</code> and the given <code>result</code> attached to it's <code>.result</code> property.
issues a warning and returns the given <code>result</code> if <code>settings.warn_only</code> is <code>True</code>.
raises a SystemExit with a return code of <code>1</code> if <code>settings.abort_exception</code> is set to None.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abort(result, err_msg, **kwargs):
    &#34;&#34;&#34;raises a `RuntimeError` with the given `err_msg` and the given `result` attached to it&#39;s `.result` property.
    issues a warning and returns the given `result` if `settings.warn_only` is `True`.
    raises a SystemExit with a return code of `1` if `settings.abort_exception` is set to None.&#34;&#34;&#34;
    base_kwargs = {
        &#34;quiet&#34;: False,
        &#34;warn_only&#34;: False,
        &#34;display_aborts&#34;: True,
        &#34;abort_exception&#34;: RuntimeError,
    }
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    if final_kwargs[&#34;warn_only&#34;]:
        if not final_kwargs[&#34;quiet&#34;]:
            LOG.warning(err_msg)
        return result

    if final_kwargs[&#34;display_aborts&#34;]:
        if not final_kwargs[&#34;quiet&#34;]:
            LOG.error(&#34;Fatal error: %s&#34; % err_msg)

    abort_exc_klass = final_kwargs[&#34;abort_exception&#34;]
    if abort_exc_klass:
        exc = abort_exc_klass(err_msg)
        setattr(exc, &#34;result&#34;, result)
        raise exc

    # https://docs.python.org/3/library/exceptions.html#SystemExit
    # # https://github.com/mathiasertl/fabric/blob/master/fabric/utils.py#L30-L63
    exc = SystemExit(1)
    exc.message = err_msg
    raise exc</code></pre>
</details>
</dd>
<dt id="threadbare.operations.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>remote_path, local_path, use_sudo=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>downloads file at <code>remote_path</code> to <code>local_path</code>, overwriting the local path if it exists.
avoid <code>use_sudo</code> if at all possible</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(remote_path, local_path, use_sudo=False, **kwargs):
    &#34;&#34;&#34;downloads file at `remote_path` to `local_path`, overwriting the local path if it exists.
    avoid `use_sudo` if at all possible&#34;&#34;&#34;

    with state.settings(quiet=True):
        if remote_path.endswith(&#34;/&#34;):
            raise ValueError(&#34;directory downloads are not supported&#34;)

        # do not raise an exception if remote path is a directory
        result = remote(
            &#39;test -d &#34;%s&#34;&#39; % remote_path, use_sudo=use_sudo, warn_only=True, quiet=True
        )
        remote_path_is_dir = result[&#34;succeeded&#34;]
        if remote_path_is_dir:
            raise ValueError(&#34;directory downloads are not supported&#34;)

        temp_file, data_buffer = None, None
        if hasattr(local_path, &#34;read&#34;):
            # given a file-like object to download file into.
            # 1. write the remote file to local temporary file
            # 2. read temporary file into the given buffer
            # 3. delete the temporary file

            data_buffer = local_path
            temp_file, local_path = tempfile.mkstemp(suffix=&#34;-threadbare&#34;)

        if not os.path.isabs(local_path):
            local_path = os.path.abspath(local_path)

        if os.path.isdir(local_path):
            local_path = os.path.join(local_path, os.path.basename(remote_path))

        if use_sudo:
            local_path = _download_as_root_hack(remote_path, local_path, **kwargs)

        else:
            if not remote_file_exists(remote_path, **kwargs):
                raise EnvironmentError(
                    &#34;remote file does not exist: %s&#34; % (remote_path,)
                )
            client = _ssh_client(**kwargs)
            transfer_fn = _transfer_fn(client, &#34;download&#34;, **kwargs)

            try:
                transfer_fn(remote_path, local_path)
            except (pssh.exceptions.SFTPError, pssh.exceptions.SCPError) as exc:
                # permissions or network issues may cause these
                raise WrappedNetworkError(exc)

        if temp_file:
            flags = &#34;r&#34; if isinstance(data_buffer, io.StringIO) else &#34;rb&#34;
            with open(local_path, flags) as fh:
                data = fh.read()
            data_buffer.write(data)
            # deletes the *temporary file*. `temp_file` is a file descriptor
            os.unlink(local_path)
            return data_buffer

        return local_path</code></pre>
</details>
</dd>
<dt id="threadbare.operations.execute_rsync_command"><code class="name flex">
<span>def <span class="ident">execute_rsync_command</span></span>(<span>cmd)</span>
</code></dt>
<dd>
<section class="desc"><p>executes given rsync <code>cmd</code>, catching rsync errors and improving any errors raised.
rsync commands can be generated with <code>_rsync_upload</code> and <code>_rsync_download</code> functions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_rsync_command(cmd):
    &#34;&#34;&#34;executes given rsync `cmd`, catching rsync errors and improving any errors raised.
    rsync commands can be generated with `_rsync_upload` and `_rsync_download` functions.
    &#34;&#34;&#34;
    try:
        return local(cmd)
    except Exception as uncaught_exc:
        if hasattr(uncaught_exc, &#34;result&#34;):
            # this is a threadbare error and we may be able to improve it
            result = uncaught_exc.result
            # taken straight from the `man` page, authored &#34;28 Jan 2018&#34;
            error_map = {
                1: &#34;Syntax or usage error&#34;,
                2: &#34;Protocol incompatibility&#34;,
                3: &#34;Errors selecting input/output files, dirs&#34;,
                4: &#34;Requested  action  not supported: an attempt was made to manipulate 64-bit files on a platform that cannot support them; or an option was specified that is supported by the client and not by the server.&#34;,
                5: &#34;Error starting client-server protocol&#34;,
                6: &#34;Daemon unable to append to log-file&#34;,
                10: &#34;Error in socket I/O&#34;,
                11: &#34;Error in file I/O&#34;,
                12: &#34;Error in rsync protocol data stream&#34;,
                13: &#34;Errors with program diagnostics&#34;,
                14: &#34;Error in IPC code&#34;,
                20: &#34;Received SIGUSR1 or SIGINT&#34;,
                21: &#34;Some error returned by waitpid()&#34;,
                22: &#34;Error allocating core memory buffers&#34;,
                23: &#34;Partial transfer due to error&#34;,
                24: &#34;Partial transfer due to vanished source files&#34;,
                25: &#34;The --max-delete limit stopped deletions&#34;,
                30: &#34;Timeout in data send/receive&#34;,
                35: &#34;Timeout waiting for daemon connection&#34;,
            }
            if result[&#34;return_code&#34;] in error_map:
                raise NetworkError(
                    &#34;rsync returned error %s: %s&#34;
                    % (result[&#34;return_code&#34;], error_map[result[&#34;return_code&#34;]])
                )
        raise uncaught_exc</code></pre>
</details>
</dd>
<dt id="threadbare.operations.handle"><code class="name flex">
<span>def <span class="ident">handle</span></span>(<span>base_kwargs, kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>handles the merging of the base set of function keyword arguments and their possible overrides.
<code>base_kwargs</code> is a map of the function's keyword arguments and their defaults.
<code>kwargs</code> are the keyword arguments used when executing the function.</p>
<p>the keys from <code>base_kwargs</code> are used to determine which keys to extract from the <code>kwargs</code> and any
global settings.</p>
<p>returns a triple of (<code>global_kwargs</code>, <code>user_kwargs</code>, <code>final_kwargs</code>) where
<code>global_kwargs</code> is the subset of keyword arguments extracted from <code>state.env</code>,
<code>user_kwargs</code> is the subset of keyword arguments extracted from the given kwargs and
<code>final_kwargs</code> is the result of merging <code>base_kwargs</code> &lt;- <code>global_kwargs</code> &lt;- <code>user_kwargs</code></p>
<p>'user' keyword arguments that are explicitly passed in take precedence over all others and
'global' keyword arguments take precedence over the function's defaults kwargs.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle(base_kwargs, kwargs):
    &#34;&#34;&#34;handles the merging of the base set of function keyword arguments and their possible overrides.
    `base_kwargs` is a map of the function&#39;s keyword arguments and their defaults.
    `kwargs` are the keyword arguments used when executing the function.

    the keys from `base_kwargs` are used to determine which keys to extract from the `kwargs` and any
    global settings.

    returns a triple of (`global_kwargs`, `user_kwargs`, `final_kwargs`) where
    `global_kwargs` is the subset of keyword arguments extracted from `state.env`,
    `user_kwargs` is the subset of keyword arguments extracted from the given kwargs and
    `final_kwargs` is the result of merging `base_kwargs` &lt;- `global_kwargs` &lt;- `user_kwargs`

    &#39;user&#39; keyword arguments that are explicitly passed in take precedence over all others and
    &#39;global&#39; keyword arguments take precedence over the function&#39;s defaults kwargs.&#34;&#34;&#34;
    key_list = base_kwargs.keys()
    global_kwargs = subdict(state.ENV, key_list)
    user_kwargs = subdict(kwargs, key_list)
    final_kwargs = merge(base_kwargs, global_kwargs, user_kwargs)
    return global_kwargs, user_kwargs, final_kwargs</code></pre>
</details>
</dd>
<dt id="threadbare.operations.hide"><code class="name flex">
<span>def <span class="ident">hide</span></span>(<span>what=None)</span>
</code></dt>
<dd>
<section class="desc"><p>hides <em>all</em> output, regardless of <code>what</code> type of output is to be hidden.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def hide(what=None):
    &#34;hides *all* output, regardless of `what` type of output is to be hidden.&#34;
    with state.settings(quiet=True):
        yield</code></pre>
</details>
</dd>
<dt id="threadbare.operations.lcd"><code class="name flex">
<span>def <span class="ident">lcd</span></span>(<span>local_dir)</span>
</code></dt>
<dd>
<section class="desc"><p>temporarily changes the local working directory</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def lcd(local_dir):
    &#34;temporarily changes the local working directory&#34;
    ensure(os.path.isdir(local_dir), &#34;not a directory: %s&#34; % local_dir)
    with state.settings():
        current_dir = cwd()
        state.add_cleanup(lambda: os.chdir(current_dir))
        os.chdir(local_dir)
        yield</code></pre>
</details>
</dd>
<dt id="threadbare.operations.local"><code class="name flex">
<span>def <span class="ident">local</span></span>(<span>command, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>preprocesses given <code>command</code> and options before executing it locally using Python's <code>subprocess.Popen</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local(command, **kwargs):
    &#34;preprocesses given `command` and options before executing it locally using Python&#39;s `subprocess.Popen`&#34;
    base_kwargs = {
        &#34;use_sudo&#34;: False,
        &#34;use_shell&#34;: True,
        &#34;combine_stderr&#34;: True,
        &#34;capture&#34;: False,
        &#34;timeout&#34;: None,
        &#34;quiet&#34;: False,
        &#34;display_running&#34;: True,
        &#34;warn_only&#34;: False,  # https://github.com/mathiasertl/fabric/blob/master/fabric/state.py#L301-L305
        &#34;abort_exception&#34;: RuntimeError,
    }
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    if final_kwargs[&#34;capture&#34;]:
        if final_kwargs[&#34;combine_stderr&#34;]:
            out_stream = subprocess.PIPE
            err_stream = subprocess.STDOUT
        else:
            out_stream = subprocess.PIPE
            err_stream = subprocess.PIPE
    else:
        if final_kwargs[&#34;quiet&#34;]:
            # we&#39;re not capturing and we&#39;ve been told to be quiet
            # send everything to /dev/null
            out_stream = subprocess.DEVNULL
            err_stream = subprocess.DEVNULL
        else:
            out_stream = None
            err_stream = None

    if not final_kwargs[&#34;use_shell&#34;] and not isinstance(command, list):
        raise ValueError(&#34;when shell=False, given command *must* be a list&#34;)

    if final_kwargs[&#34;use_shell&#34;]:
        command = shell_wrap_command(command)

    if final_kwargs[&#34;use_sudo&#34;]:
        if final_kwargs[&#34;use_shell&#34;]:
            command = sudo_wrap_command(command)
        else:
            # lsh@2020-04: is this a good enough sudo command?
            # nothing uses local+noshell+sudo (at time of writing)
            command = [&#34;sudo&#34;, &#34;--non-interactive&#34;] + command

    proc = subprocess.Popen(
        command, shell=final_kwargs[&#34;use_shell&#34;], stdout=out_stream, stderr=err_stream
    )
    _print_running(command, sys.stdout, **final_kwargs)
    if final_kwargs[&#34;timeout&#34;]:
        timer = Timer(final_kwargs[&#34;timeout&#34;], proc.kill)
        try:
            timer.start()  # proximity matters
            stdout, stderr = proc.communicate()
        finally:
            timer.cancel()
    else:
        stdout, stderr = proc.communicate()

    # https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L1240-L1244
    result = {
        &#34;return_code&#34;: proc.returncode,
        &#34;failed&#34;: proc.returncode != 0,
        &#34;succeeded&#34;: proc.returncode == 0,
        &#34;command&#34;: command,
        &#34;stdout&#34;: (stdout or b&#34;&#34;).decode(&#34;utf-8&#34;).splitlines(),
        &#34;stderr&#34;: (stderr or b&#34;&#34;).decode(&#34;utf-8&#34;).splitlines(),
    }

    if result[&#34;succeeded&#34;]:
        return result

    err_msg = &#34;local() encountered an error (return code %s) while executing %r&#34; % (
        result[&#34;return_code&#34;],
        command,
    )

    # if `warn_only` is True this function may still return a result
    return abort(result, err_msg, **final_kwargs)</code></pre>
</details>
</dd>
<dt id="threadbare.operations.pem_key"><code class="name flex">
<span>def <span class="ident">pem_key</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>returns the first private key found in a list of common private keys.
if none of the keys exist, the default (first) key will be returned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pem_key():
    &#34;&#34;&#34;returns the first private key found in a list of common private keys.
    if none of the keys exist, the default (first) key will be returned.&#34;&#34;&#34;
    id_list = [&#34;id_rsa&#34;, &#34;id_dsa&#34;, &#34;identity&#34;, &#34;id_ecdsa&#34;]
    id_list = [os.path.expanduser(&#34;~/.ssh/&#34; + idstr) for idstr in id_list]
    for id_path in id_list:
        if os.path.isfile(id_path):
            return id_path
        LOG.debug(&#34;key not found: %s&#34; % id_path)

    default = id_list[0]
    return default</code></pre>
</details>
</dd>
<dt id="threadbare.operations.prompt"><code class="name flex">
<span>def <span class="ident">prompt</span></span>(<span>msg)</span>
</code></dt>
<dd>
<section class="desc"><p>issues a prompt for input.
raises a <code>PromptedException</code> if <code>abort_on_prompts</code> in <code>state.ENV</code> is <code>True</code> or executing within
another process using <code>execute.parallel</code> where input can't be supplied.
if <code>abort_exception</code> is set in <code>state.ENV</code>, then that exception is raised instead</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prompt(msg):
    &#34;&#34;&#34;issues a prompt for input.
    raises a `PromptedException` if `abort_on_prompts` in `state.ENV` is `True` or executing within
    another process using `execute.parallel` where input can&#39;t be supplied.
    if `abort_exception` is set in `state.ENV`, then that exception is raised instead&#34;&#34;&#34;
    if state.ENV.get(&#34;abort_on_prompts&#34;, False):
        abort_ex = state.ENV.get(&#34;abort_exception&#34;, PromptedException)
        raise abort_ex(&#34;prompted with: %s&#34; % (msg,))
    print(msg)
    try:
        return raw_input(&#34;&gt; &#34;)
    except NameError:
        return input(&#34;&gt; &#34;)</code></pre>
</details>
</dd>
<dt id="threadbare.operations.rcd"><code class="name flex">
<span>def <span class="ident">rcd</span></span>(<span>remote_working_dir)</span>
</code></dt>
<dd>
<section class="desc"><p>ensures all commands run are done from the given remote directory. if remote directory doesn't exist, command will not be run</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def rcd(remote_working_dir):
    &#34;ensures all commands run are done from the given remote directory. if remote directory doesn&#39;t exist, command will not be run&#34;
    with state.settings(remote_working_dir=remote_working_dir):
        yield</code></pre>
</details>
</dd>
<dt id="threadbare.operations.remote"><code class="name flex">
<span>def <span class="ident">remote</span></span>(<span>command, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>preprocesses given <code>command</code> and options before sending it to <code>_execute</code> to be executed on remote host</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remote(command, **kwargs):
    &#34;preprocesses given `command` and options before sending it to `_execute` to be executed on remote host&#34;

    # Fabric function signature for `run`
    # shell=True # done
    # pty=True   # mutually exclusive with `combine_stderr` in pssh. not sure how Fabric/Paramiko is doing it
    # combine_stderr=None # mutually exclusive with use_pty. &#39;True&#39; in global env.
    # quiet=False, # done
    # warn_only=False # done
    # stdout=None # done, stdout/stderr always available unless explicitly discarded. &#39;see discard_output&#39;
    # stderr=None # done, stderr not available when combine_stderr is `True`
    # timeout=None # done
    # shell_escape=None # ignored. shell commands are always escaped
    # capture_buffer_size=None # correlates to `ssh2.channel.read` and the `size` parameter. Ignored.

    # parameters we&#39;re interested in and their default values
    base_kwargs = _ssh_default_settings()
    base_kwargs.update({&#34;display_running&#34;: True, &#34;discard_output&#34;: False})
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    # wrap the command up
    # https://github.com/mathiasertl/fabric/blob/master/fabric/operations.py#L920-L925
    if final_kwargs[&#34;remote_working_dir&#34;]:
        command = cwd_wrap_command(command, final_kwargs[&#34;remote_working_dir&#34;])
    if final_kwargs[&#34;use_shell&#34;]:
        command = shell_wrap_command(command)
    if final_kwargs[&#34;use_sudo&#34;]:
        command = sudo_wrap_command(command)

    # if use_pty is True, stdout and stderr are combined and stderr will yield nothing.
    # - https://parallel-ssh.readthedocs.io/en/latest/advanced.html#combined-stdout-stderr
    use_pty = final_kwargs[&#34;combine_stderr&#34;]

    # values `remote` specifically passes to `_execute`
    execute_kwargs = {&#34;command&#34;: command, &#34;use_pty&#34;: use_pty}
    execute_kwargs = merge(final_kwargs, execute_kwargs)
    execute_kwargs = subdict(
        execute_kwargs,
        [
            &#34;command&#34;,
            &#34;user&#34;,
            &#34;key_filename&#34;,
            &#34;host_string&#34;,
            &#34;port&#34;,
            &#34;use_pty&#34;,
            &#34;timeout&#34;,
        ],
    )

    # TODO: validate `_execute`s args. `host_string` can&#39;t be None for example

    # run command
    _print_running(command, sys.stdout, **final_kwargs)
    result = _execute(**execute_kwargs)

    # handle stdout/stderr streams
    output_kwargs = subdict(final_kwargs, [&#34;quiet&#34;, &#34;discard_output&#34;])
    stdout = _process_output(sys.stdout, result[&#34;stdout&#34;], **output_kwargs)
    stderr = _process_output(sys.stderr, result[&#34;stderr&#34;], **output_kwargs)

    # command must have finished before we have access to return code
    return_code = result[&#34;return_code&#34;]()
    result.update(
        {
            &#34;stdout&#34;: stdout,
            &#34;stderr&#34;: stderr,
            &#34;return_code&#34;: return_code,
            &#34;failed&#34;: return_code &gt; 0,
            &#34;succeeded&#34;: return_code == 0,
        }
    )

    if result[&#34;succeeded&#34;]:
        return result

    err_msg = &#34;remote() encountered an error (return code %s) while executing %r&#34; % (
        result[&#34;return_code&#34;],
        command,
    )

    # if `warn_only` is True this function may still return a result
    return abort(result, err_msg, **final_kwargs)</code></pre>
</details>
</dd>
<dt id="threadbare.operations.remote_file_exists"><code class="name flex">
<span>def <span class="ident">remote_file_exists</span></span>(<span>path, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>returns True if given path exists on remote system</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remote_file_exists(path, **kwargs):
    &#34;returns True if given path exists on remote system&#34;
    # note: Fabric is doing something weird and clever here:
    # - https://github.com/mathiasertl/fabric/blob/master/fabric/contrib/files.py#L474-L485
    # but their examples don&#39;t work:

    # $ /bin/sh
    # sh-5.0$ foo=&#34;$(echo /usr/\*/share)&#34;
    # sh-5.0$ echo $foo
    # /usr/*/share
    # sh-5.0$ exit
    # $ echo $SHELL
    # $ /bin/bash
    # $ foo=&#34;$(echo /usr/\*/share)&#34;
    # $ echo $foo
    # /usr/*/share

    # TODO: revisit
    # update 2020/01: it does work, I just had no &#34;/usr/[anything]/share&#34; directories.
    # this works for me:
    #   foo=$(echo /\*/share/)
    #   echo $foo
    #   /usr/share/

    base_kwargs = {
        &#34;use_sudo&#34;: False,
    }
    global_kwargs, user_kwargs, final_kwargs = handle(base_kwargs, kwargs)

    # do not raise an exception if remote file doesn&#39;t exist
    final_kwargs[&#34;warn_only&#34;] = True

    remote_fn = remote_sudo if final_kwargs[&#34;use_sudo&#34;] else remote
    command = &#34;test -e %s&#34; % path
    return remote_fn(command, **final_kwargs)[&#34;return_code&#34;] == 0</code></pre>
</details>
</dd>
<dt id="threadbare.operations.remote_sudo"><code class="name flex">
<span>def <span class="ident">remote_sudo</span></span>(<span>command, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>exactly the same as <code><a title="threadbare.operations.remote" href="#threadbare.operations.remote">remote()</a></code>, but the given command is run as the root user</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remote_sudo(command, **kwargs):
    &#34;exactly the same as `remote`, but the given command is run as the root user&#34;
    # user=None  # ignore
    # group=None # ignore
    kwargs[&#34;use_sudo&#34;] = True
    return remote(command, **kwargs)</code></pre>
</details>
</dd>
<dt id="threadbare.operations.rsync_download"><code class="name flex">
<span>def <span class="ident">rsync_download</span></span>(<span>remote_path, local_path, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>copies <code>remote_path</code> to <code>local_path</code> using values in the current <code>state.ENV</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rsync_download(remote_path, local_path, **kwargs):
    &#34;copies `remote_path` to `local_path` using values in the current `state.ENV`.&#34;
    abs_local_path = os.path.abspath(os.path.expanduser(local_path))
    abs_local_dir = os.path.dirname(abs_local_path)
    if not os.path.exists(abs_local_dir):
        # replicates behaviour of downloading via scp and sftp (via parallel-ssh)
        local(&#34;mkdir -p %r&#34; % (abs_local_dir,))
    return execute_rsync_command(_rsync_download(remote_path, local_path, **kwargs))</code></pre>
</details>
</dd>
<dt id="threadbare.operations.rsync_upload"><code class="name flex">
<span>def <span class="ident">rsync_upload</span></span>(<span>local_path, remote_path, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>copies <code>local_path</code> to <code>remote_path</code> using values in the current <code>state.ENV</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rsync_upload(local_path, remote_path, **kwargs):
    &#34;copies `local_path` to `remote_path` using values in the current `state.ENV`.&#34;
    remote_dir = os.path.dirname(remote_path)
    if not remote_file_exists(remote_dir):
        remote(&#34;mkdir -p %r&#34; % remote_dir)
    return execute_rsync_command(_rsync_upload(local_path, remote_path, **kwargs))</code></pre>
</details>
</dd>
<dt id="threadbare.operations.single_command"><code class="name flex">
<span>def <span class="ident">single_command</span></span>(<span>cmd_list)</span>
</code></dt>
<dd>
<section class="desc"><p>given a list of commands to run, returns a single command.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def single_command(cmd_list):
    &#34;given a list of commands to run, returns a single command.&#34;
    # `remote` and `local` will do any escaping as necessary
    if cmd_list in [None, []]:
        return None
    return &#34; &amp;&amp; &#34;.join(map(str, cmd_list))</code></pre>
</details>
</dd>
<dt id="threadbare.operations.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>local_path, remote_path, use_sudo=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>uploads file at <code>local_path</code> to the given <code>remote_path</code>, overwriting anything that may be at that path</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(local_path, remote_path, use_sudo=False, **kwargs):
    &#34;uploads file at `local_path` to the given `remote_path`, overwriting anything that may be at that path&#34;
    # todo: this setting is dubious, don&#39;t count on it hanging around
    with state.settings(quiet=True):

        # bytes handling
        local_path, cleanup_fn = _write_bytes_to_temporary_file(local_path)
        if cleanup_fn:
            state.add_cleanup(cleanup_fn)

        if os.path.isdir(local_path):
            raise ValueError(&#34;folders cannot be uploaded&#34;)

        if use_sudo:
            return _upload_as_root_hack(local_path, remote_path, **kwargs)

        if not os.path.exists(local_path):
            raise EnvironmentError(&#34;local file does not exist: %s&#34; % (local_path,))

        client = _ssh_client(**kwargs)

        try:
            transfer_fn = _transfer_fn(client, &#34;upload&#34;, **kwargs)
            transfer_fn(local_path, remote_path)
        except (pssh.exceptions.SFTPError, pssh.exceptions.SCPError) as exc:
            # permissions or network issues may cause these
            raise WrappedNetworkError(exc)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="threadbare.operations.NetworkError"><code class="flex name class">
<span>class <span class="ident">NetworkError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>generic 'died while doing something network-related' catch-all exception class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetworkError(Exception):
    &#34;generic &#39;died while doing something network-related&#39; catch-all exception class.&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="threadbare.operations.WrappedNetworkError" href="#threadbare.operations.WrappedNetworkError">WrappedNetworkError</a></li>
</ul>
</dd>
<dt id="threadbare.operations.SSHClient"><code class="flex name class">
<span>class <span class="ident">SSHClient</span></span>
<span>(</span><span>host, user=None, password=None, port=None, pkey=None, alias=None, num_retries=3, retry_delay=5, allow_agent=True, timeout=None, forward_ssh_agent=False, proxy_host=None, proxy_port=None, proxy_pkey=None, proxy_user=None, proxy_password=None, keepalive_seconds=60, identity_auth=True, ipv6_only=False)</span>
</code></dt>
<dd>
<section class="desc"><p>ssh2-python (libssh2) based non-blocking SSH client.</p>
<p>:param host: Host name or IP to connect to.
:type host: str
:param user: User to connect as. Defaults to logged in user.
:type user: str
:param password: Password to use for password authentication.
:type password: str
:param alias: Use an alias for this host.
:type alias: str
:param port: SSH port to connect to. Defaults to SSH default (22)
:type port: int
:param pkey: Private key file path to use for authentication. Path must
be either absolute path or relative to user home directory
like <code>~/&lt;path&gt;</code>.
Bytes type input is used as private key data for authentication.
:type pkey: str or bytes
:param num_retries: (Optional) Number of connection and authentication
attempts before the client gives up. Defaults to 3.
:type num_retries: int
:param retry_delay: Number of seconds to wait between retries. Defaults
to :py:class:<code>pssh.constants.RETRY_DELAY</code>
:type retry_delay: int or float
:param timeout: SSH session timeout setting in seconds. This controls
timeout setting of authenticated SSH sessions.
:type timeout: int or float
:param allow_agent: (Optional) set to False to disable connecting to
the system's SSH agent
:type allow_agent: bool
:param identity_auth: (Optional) set to False to disable attempting to
authenticate with default identity files from
<code>pssh.clients.base.single.BaseSSHClient.IDENTITIES</code>
:type identity_auth: bool
:param forward_ssh_agent: Unused - agent forwarding not implemented.
:type forward_ssh_agent: bool
:param proxy_host: Connect to target host via given proxy host.
:type proxy_host: str
:param proxy_port: Port to use for proxy connection. Defaults to self.port
:type proxy_port: int
:param keepalive_seconds: Interval of keep alive messages being sent to
server. Set to <code>0</code> or <code>False</code> to disable.
:type keepalive_seconds: int
:param ipv6_only: Choose IPv6 addresses only if multiple are available
for the host or raise NoIPv6AddressFoundError otherwise. Note this will
disable connecting to an IPv4 address if an IP address is provided instead.
:type ipv6_only: bool</p>
<p>:raises: :py:class:<code>pssh.exceptions.PKeyFileError</code> on errors finding
provided private key.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SSHClient(PSSHClient):
    def __deepcopy__(self, memo):
        # do not copy.deepcopy ourselves or the pssh SSHClient object, just
        # return a reference to the object (self)
        # - https://docs.python.org/3/library/copy.html
        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pssh.clients.native.single.SSHClient</li>
<li>pssh.clients.base.single.BaseSSHClient</li>
</ul>
</dd>
<dt id="threadbare.operations.WrappedNetworkError"><code class="flex name class">
<span>class <span class="ident">WrappedNetworkError</span></span>
<span>(</span><span>exc)</span>
</code></dt>
<dd>
<section class="desc"><p>groups several exceptions into a single WrappedNetworkError</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WrappedNetworkError(NetworkError):
    &#34;groups several exceptions into a single WrappedNetworkError&#34;

    def __init__(self, exc):
        self.wrapped = exc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="threadbare.operations.NetworkError" href="#threadbare.operations.NetworkError">NetworkError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="threadbare" href="index.html">threadbare</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="threadbare.operations.abort" href="#threadbare.operations.abort">abort</a></code></li>
<li><code><a title="threadbare.operations.download" href="#threadbare.operations.download">download</a></code></li>
<li><code><a title="threadbare.operations.execute_rsync_command" href="#threadbare.operations.execute_rsync_command">execute_rsync_command</a></code></li>
<li><code><a title="threadbare.operations.handle" href="#threadbare.operations.handle">handle</a></code></li>
<li><code><a title="threadbare.operations.hide" href="#threadbare.operations.hide">hide</a></code></li>
<li><code><a title="threadbare.operations.lcd" href="#threadbare.operations.lcd">lcd</a></code></li>
<li><code><a title="threadbare.operations.local" href="#threadbare.operations.local">local</a></code></li>
<li><code><a title="threadbare.operations.pem_key" href="#threadbare.operations.pem_key">pem_key</a></code></li>
<li><code><a title="threadbare.operations.prompt" href="#threadbare.operations.prompt">prompt</a></code></li>
<li><code><a title="threadbare.operations.rcd" href="#threadbare.operations.rcd">rcd</a></code></li>
<li><code><a title="threadbare.operations.remote" href="#threadbare.operations.remote">remote</a></code></li>
<li><code><a title="threadbare.operations.remote_file_exists" href="#threadbare.operations.remote_file_exists">remote_file_exists</a></code></li>
<li><code><a title="threadbare.operations.remote_sudo" href="#threadbare.operations.remote_sudo">remote_sudo</a></code></li>
<li><code><a title="threadbare.operations.rsync_download" href="#threadbare.operations.rsync_download">rsync_download</a></code></li>
<li><code><a title="threadbare.operations.rsync_upload" href="#threadbare.operations.rsync_upload">rsync_upload</a></code></li>
<li><code><a title="threadbare.operations.single_command" href="#threadbare.operations.single_command">single_command</a></code></li>
<li><code><a title="threadbare.operations.upload" href="#threadbare.operations.upload">upload</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="threadbare.operations.NetworkError" href="#threadbare.operations.NetworkError">NetworkError</a></code></h4>
</li>
<li>
<h4><code><a title="threadbare.operations.SSHClient" href="#threadbare.operations.SSHClient">SSHClient</a></code></h4>
</li>
<li>
<h4><code><a title="threadbare.operations.WrappedNetworkError" href="#threadbare.operations.WrappedNetworkError">WrappedNetworkError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="/threadbare/resources/third-party/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>